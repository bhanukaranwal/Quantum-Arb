/*
 * QuantumArb 2.0 - Core Services: Strategy Engine (SOR Integrated)
 *
 * File: src/core_services/strategy_engine/main.rs
 *
 * Description:
 * This is the most advanced version of the Strategy Engine, now featuring a
 * Smart Order Router (SOR). Instead of just finding arbitrage opportunities,
 * it can now calculate an optimal execution plan for a desired trade size by
 * intelligently splitting the order across multiple venues.
 *
 * This minimizes market impact and slippage, leading to better execution prices.
 */

use serde::Deserialize;
use std::time::Duration;
use tokio::time;

// --- Data Structures ---

/// Represents a single level in the order book.
#[derive(Debug, Clone, Deserialize, Copy)]
struct OrderBookLevel {
    price: u64,
    size: u32,
}

/// Represents a snapshot of the order book from a venue.
#[derive(Debug, Clone, Deserialize)]
struct MarketUpdate {
    instrument_id: u32,
    // Top 5 levels of the book
    bids: Vec<OrderBookLevel>,
    asks: Vec<OrderBookLevel>,
}

/// A single leg of an execution plan.
#[derive(Debug, Clone)]
struct TradeAction {
    venue_id: u32,
    price: u64,
    size: u32,
}

/// The complete execution plan generated by the SOR.
#[derive(Debug)]
struct ExecutionPlan {
    actions: Vec<TradeAction>,
    average_price: f64,
    total_cost: f64,
    total_size: u32,
}

// --- Main Application Logic ---

#[tokio::main]
async fn main() {
    println!("--- Starting QuantumArb 2.0 Strategy Engine (SOR Integrated) ---");

    let mut interval = time::interval(Duration::from_secs(5));
    loop {
        interval.tick().await;

        // 1. Simulate receiving full order book updates from two venues.
        let venue_a_update = get_simulated_market_update(1);
        let venue_b_update = get_simulated_market_update(2);
        println!("\nReceived market updates from Venue A & B.");

        // 2. Define a desired trade: e.g., we want to buy 50 units.
        let desired_trade_size: u32 = 50;
        println!("  -> Goal: Buy {} units.", desired_trade_size);

        // 3. Use the SOR to calculate the best execution plan.
        if let Some(plan) = calculate_sor_execution_plan(desired_trade_size, &venue_a_update, &venue_b_update) {
            println!("--- SOR Execution Plan ---");
            println!("  -> Total Size: {}", plan.total_size);
            println!("  -> Average Price: {:.2}", plan.average_price);
            println!("  -> Total Cost: ${:.2}", plan.total_cost / 100.0);
            for action in plan.actions {
                println!("    - Execute on Venue {}: Buy {} @ {}", action.venue_id, action.size, action.price);
            }
        } else {
            println!("  -> Could not generate an execution plan (insufficient liquidity).");
        }
    }
}

/// Simulates receiving a multi-level market data update.
fn get_simulated_market_update(venue_id: u32) -> MarketUpdate {
    if venue_id == 1 {
        MarketUpdate {
            instrument_id: 1,
            bids: vec![], // Not needed for a buy order
            asks: vec![ // Liquidity available to buy from
                OrderBookLevel { price: 60010, size: 20 },
                OrderBookLevel { price: 60012, size: 40 },
                OrderBookLevel { price: 60015, size: 50 },
            ],
        }
    } else {
        MarketUpdate {
            instrument_id: 1,
            bids: vec![],
            asks: vec![
                OrderBookLevel { price: 60011, size: 35 },
                OrderBookLevel { price: 60013, size: 30 },
                OrderBookLevel { price: 60014, size: 60 },
            ],
        }
    }
}

/// The core Smart Order Router logic.
fn calculate_sor_execution_plan(
    mut size_to_buy: u32,
    venue_a: &MarketUpdate,
    venue_b: &MarketUpdate,
) -> Option<ExecutionPlan> {
    let mut actions = Vec::new();
    let mut total_cost: u64 = 0;
    let total_size_bought: u32 = size_to_buy;

    // Combine all available ask levels from both venues into a single list
    let mut all_asks: Vec<(OrderBookLevel, u32)> = venue_a.asks.iter().map(|&l| (l, venue_a.instrument_id)).collect();
    all_asks.extend(venue_b.asks.iter().map(|&l| (l, venue_b.instrument_id)));

    // Sort all available liquidity by the best price (lowest ask)
    all_asks.sort_by_key(|a| a.0.price);

    for (level, venue_id) in all_asks {
        if size_to_buy == 0 {
            break;
        }

        // How much can we take from this level?
        let size_to_take = std::cmp::min(size_to_buy, level.size);
        
        actions.push(TradeAction {
            venue_id,
            price: level.price,
            size: size_to_take,
        });

        total_cost += level.price * size_to_take as u64;
        size_to_buy -= size_to_take;
    }

    // If we couldn't fill the entire desired size, the plan is invalid.
    if size_to_buy > 0 {
        return None;
    }

    Some(ExecutionPlan {
        actions,
        average_price: total_cost as f64 / total_size_bought as f64,
        total_cost: total_cost as f64,
        total_size: total_size_bought,
    })
}
